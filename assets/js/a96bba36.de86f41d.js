"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["876850"],{596151:function(e,t,n){n.r(t),n.d(t,{default:()=>d,frontMatter:()=>s,metadata:()=>l,assets:()=>o,toc:()=>u,contentTitle:()=>r});var l=JSON.parse('{"id":"query-acceleration/tuning/parallelism-tuning","title":"Parallelism Tuning","description":"\x3c!--","source":"@site/versioned_docs/version-3.0/query-acceleration/tuning/parallelism-tuning.md","sourceDirName":"query-acceleration/tuning","slug":"/query-acceleration/tuning/parallelism-tuning","permalink":"/docs/3.0/query-acceleration/tuning/parallelism-tuning","draft":false,"unlisted":false,"tags":[],"version":"3.0","frontMatter":{"title":"Parallelism Tuning","language":"en"},"sidebar":"docs","previous":{"title":"Common Tuning Parameters","permalink":"/docs/3.0/query-acceleration/tuning/tuning-parameters"},"next":{"title":"Query Optimizers","permalink":"/docs/3.0/query-acceleration/optimization-technology-principle/query-optimizer"}}'),i=n("785893"),a=n("250065");let s={title:"Parallelism Tuning",language:"en"},r="Parallelism Tuning",o={},u=[{value:"Principles of Parallelism Tuning",id:"principles-of-parallelism-tuning",level:2},{value:"Examples",id:"examples",level:3},{value:"Methods of Parallelism Tuning",id:"methods-of-parallelism-tuning",level:2},{value:"SQL Level Adjustment:",id:"sql-level-adjustment",level:3},{value:"Session Level Adjustment:",id:"session-level-adjustment",level:3},{value:"Global Adjustment:",id:"global-adjustment",level:3}];function c(e){let t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"parallelism-tuning",children:"Parallelism Tuning"})}),"\n",(0,i.jsx)(t.p,{children:"Doris's query is an MPP execution framework, and each query will be executed in parallel on multiple BEs. At the same time, within a single BE, a multi-threaded parallel approach is also adopted to accelerate the query execution efficiency. Currently, all statements (including Query, DML, DDL) support parallel execution."}),"\n",(0,i.jsx)(t.p,{children:"The control parameter for the parallelism within a single BE is: parallel_pipeline_task_num, which refers to the number of working tasks used when a single Fragment is executed."}),"\n",(0,i.jsx)(t.h2,{id:"principles-of-parallelism-tuning",children:"Principles of Parallelism Tuning"}),"\n",(0,i.jsxs)(t.p,{children:["The purpose of setting ",(0,i.jsx)(t.code,{children:"parallel_pipeline_task_num"})," is to fully utilize multi-core resources and reduce query latency. However, in order to achieve multi-core parallel execution, some data Shuffle operators and multi-thread synchronization logic are usually introduced, which also brings some unnecessary resource waste."]}),"\n",(0,i.jsx)(t.p,{children:"The default value in Doris is 0, which is half of the number of CPU cores of the BE. This value takes into account the resource utilization of single queries and concurrent situations, and usually does not require user intervention for adjustment. When there is a performance bottleneck, the following examples can be referred to for necessary adjustments. Doris is continuously improving the adaptive strategy, and it is usually recommended to make necessary adjustments in specific scenarios or at the SQL level."}),"\n",(0,i.jsx)(t.h3,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(t.p,{children:"Suppose the number of CPU cores of the BE is 16:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["For simple operations on a single table (such as single-table point query, where scan to obtain a small amount of data, limit a small amount of data, hit a materialized view), ",(0,i.jsx)(t.strong,{children:"the parallelism can be set to 1"}),".\nExplanation: For simple operations on a single table, there is only one Fragment. The bottleneck of the query is usually in the data scanning and processing. The data scanning thread and the query execution thread are separated. The data scanning thread will adaptively perform parallel scanning. The bottleneck here is not the query thread, so the parallelism can be directly set to 1."]}),"\n",(0,i.jsxs)(t.li,{children:["For queries with two-table JOIN/aggregate queries, if the data volume is very large and it is confirmed to be a CPU bottleneck query, ",(0,i.jsx)(t.strong,{children:"the parallelism can be set to 16"}),".\nExplanation: For two-table JOIN/aggregate queries, which are data computation-intensive queries, if it is observed that the CPU is not fully utilized, consider further increasing the parallelism on the basis of the default value, using the parallel ability of the Pipeline execution engine to fully utilize CPU resources for computation. It cannot be guaranteed that each PipelineTask can use the CPU resources allocated to it to the limit. Therefore, the parallelism can be appropriately adjusted, for example, set to 16, to make more full use of the CPU. However, the parallelism should not be increased indefinitely. Setting it to 48 will not bring substantial benefits, but will increase thread scheduling overhead and framework scheduling overhead."]}),"\n",(0,i.jsxs)(t.li,{children:["For the stress testing scenario, if the multiple query tasks in the stress test can fully utilize the CPU, consider ",(0,i.jsx)(t.strong,{children:"setting the parallelism to 1"}),".\nExplanation: For the stress testing scenario, there are enough query tasks in the stress test. Excessive parallelism also brings thread scheduling overhead and framework scheduling overhead. It is more reasonable to set it to 1 here."]}),"\n",(0,i.jsx)(t.li,{children:"For complex queries, it is necessary to flexibly adjust according to the Profile and machine load. Here, it is recommended to use the default value. If it is not appropriate, you can try to adjust it in a stepwise manner of 4-2-1 and observe the query performance and machine load."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"methods-of-parallelism-tuning",children:"Methods of Parallelism Tuning"}),"\n",(0,i.jsx)(t.p,{children:"Doris can manually specify the parallelism of a query to adjust the parallel execution efficiency when the query is executed."}),"\n",(0,i.jsx)(t.h3,{id:"sql-level-adjustment",children:"SQL Level Adjustment:"}),"\n",(0,i.jsx)(t.p,{children:"Use SQL HINT to specify the parallelism of a single SQL, so that the parallelism of different SQLs can be flexibly controlled to achieve the best execution effect."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:'select /*SET_VAR("parallel_pipeline_task_num=8")*/ * from nation, lineitem where lineitem.l_suppkey = nation.n_nationkey\n'})}),"\n",(0,i.jsx)(t.h3,{id:"session-level-adjustment",children:"Session Level Adjustment:"}),"\n",(0,i.jsx)(t.p,{children:"Adjust the parallelism at the session level through session variables. All query statements in the session will be executed with the specified parallelism. Please note that even a single-line query SQL will use this parallelism, which may lead to performance degradation."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"set parallel_pipeline_task_num = 8;\n"})}),"\n",(0,i.jsx)(t.h3,{id:"global-adjustment",children:"Global Adjustment:"}),"\n",(0,i.jsx)(t.p,{children:"If global adjustment is required, usually involving the adjustment of CPU utilization, the parallelism can be set globally."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-SQL",children:"set global parallel_pipeline_task_num = 8;\n"})})]})}function d(e={}){let{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return r},a:function(){return s}});var l=n(667294);let i={},a=l.createContext(i);function s(e){let t=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),l.createElement(a.Provider,{value:t},e.children)}}}]);